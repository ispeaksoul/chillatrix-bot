{"file_contents":{"commands/hello.js":{"content":"const { SlashCommandBuilder } = require('discord.js');\r\n\r\nmodule.exports = {\r\n  data: new SlashCommandBuilder()\r\n    .setName('hello')\r\n    .setDescription('Say hello'),\r\n  async execute(interaction) {\r\n    await interaction.reply('Hello! How can I assist you today?');\r\n  },\r\n};\r\n","path":null,"size_bytes":281,"size_tokens":null},"commands/moveall.js":{"content":"const { SlashCommandBuilder, ChannelType, PermissionsBitField } = require('discord.js');\r\nconst { MessageFlags } = require('discord.js');\r\n\r\n\r\nmodule.exports = {\r\n  data: new SlashCommandBuilder()\r\n    .setName('moveall')\r\n    .setDescription('Move all members from one VC to another')\r\n    .addChannelOption(option =>\r\n      option.setName('from')\r\n        .setDescription('Source voice channel')\r\n        .addChannelTypes(ChannelType.GuildVoice)\r\n        .setRequired(true)\r\n    )\r\n    .addChannelOption(option =>\r\n      option.setName('to')\r\n        .setDescription('Target voice channel')\r\n        .addChannelTypes(ChannelType.GuildVoice)\r\n        .setRequired(true)\r\n    ),\r\n  async execute(interaction) {\r\n    const fromChannel = interaction.options.getChannel('from');\r\n    const toChannel = interaction.options.getChannel('to');\r\n\r\n    // Check bot's permission to move members\r\n    if (!interaction.guild.members.me.permissions.has(PermissionsBitField.Flags.MoveMembers)) {\r\n      return interaction.reply({ content: '‚ùå I need the **Move Members** permission to do that.', flags: MessageFlags.Ephemeral });\r\n    }\r\n\r\n    const membersToMove = fromChannel.members;\r\n\r\n    if (!membersToMove || membersToMove.size === 0) {\r\n      return interaction.reply({ content: `‚ùå No members found in ${fromChannel.name}.`, flags: MessageFlags.Ephemeral });\r\n    }\r\n\r\n    for (const [_, member] of membersToMove) {\r\n      try {\r\n        await member.voice.setChannel(toChannel);\r\n      } catch (err) {\r\n        console.error(`‚ùå Failed to move ${member.user.tag}:`, err);\r\n      }\r\n    }\r\n\r\n    await interaction.reply({\r\n      content: `‚úÖ Moved ${membersToMove.size} member(s) from ${fromChannel.name} to ${toChannel.name}.`,\r\n      flags: MessageFlags.Ephemeral\r\n    });\r\n  }\r\n};\r\n","path":null,"size_bytes":1785,"size_tokens":null},"index.js":{"content":"const { Client, IntentsBitField, Collection } = require(\"discord.js\");\r\nrequire(\"dotenv\").config();\nrequire(\"./keepalive\");\r\nconst fs = require(\"fs\");\r\n\r\nconst client = new Client({\r\n  intents: [\r\n    IntentsBitField.Flags.Guilds,\r\n    IntentsBitField.Flags.GuildMessages,\n    IntentsBitField.Flags.GuildMembers, // ‚úÖ Required to receive join events\r\n    IntentsBitField.Flags.MessageContent,\r\n    IntentsBitField.Flags.DirectMessages,\r\n  ],\r\n  partials: [\"CHANNEL\", \"MESSAGE\"], // Required to receive DMs\r\n});\r\n\r\nclient.commands = new Collection();\r\n\r\n// Load commands\r\nconst commandFiles = fs\n  .readdirSync(\"./commands\")\n  .filter((file) => file.endsWith(\".js\"));\r\nfor (const file of commandFiles) {\r\n  const command = require(`./commands/${file}`);\r\n  client.commands.set(command.data.name, command);\r\n}\r\n\r\n// Load events\r\nconst eventFiles = fs\n  .readdirSync(\"./events\")\n  .filter((file) => file.endsWith(\".js\"));\r\nfor (const file of eventFiles) {\r\n  const event = require(`./events/${file}`);\r\n  if (event.once) {\r\n    client.once(event.name, (...args) => event.execute(...args, client));\r\n  } else {\r\n    client.on(event.name, (...args) => event.execute(...args, client));\r\n  }\r\n}\r\n\r\nclient.login(process.env.TOKEN);\r\n","path":null,"size_bytes":1227,"size_tokens":null},"utils/permissions.js":{"content":"const { PermissionsBitField } = require('discord.js');\r\nconst config = require('../config.json');\r\n\r\nfunction hasRequiredRole(member) {\r\n  if (!member || config.requiredRoleIds.length === 0) return false;\r\n  return config.requiredRoleIds.some(id => member.roles.cache.has(id));\r\n}\r\n\r\nfunction hasAdminPermission(member) {\r\n  return member?.permissions?.has(PermissionsBitField.Flags.Administrator) ?? false;\r\n}\r\n\r\nmodule.exports = { hasRequiredRole, hasAdminPermission };\r\n","path":null,"size_bytes":473,"size_tokens":null},"commands/unmute.js":{"content":"const { SlashCommandBuilder } = require('discord.js');\r\nconst { MessageFlags } = require('discord.js');\r\n\r\n\r\nmodule.exports = {\r\n  data: new SlashCommandBuilder()\r\n    .setName('unmute')\r\n    .setDescription('Unmute a user in voice channel')\r\n    .addUserOption(option =>\r\n      option.setName('target')\r\n        .setDescription('User to unmute')\r\n        .setRequired(true)),\r\n  async execute(interaction) {\r\n    const member = interaction.options.getMember('target');\r\n\r\n    if (!member.voice.channel) {\r\n      return interaction.reply({ content: '‚ùå User is not in a voice channel.', flags: MessageFlags.Ephemeral });\r\n    }\r\n\r\n    try {\r\n      await member.voice.setMute(false);\r\n      await interaction.reply(`üîä ${member.user.tag} has been unmuted.`);\r\n    } catch (error) {\r\n      console.error('Unmute error:', error);\r\n      await interaction.reply({ content: '‚ùå Failed to unmute the user.', flags: MessageFlags.Ephemeral });\r\n    }\r\n  }\r\n};\r\n","path":null,"size_bytes":957,"size_tokens":null},"events/guildMemberAdd.js":{"content":"module.exports = {\n  name: \"guildMemberAdd\",\n  async execute(member) {\n    // Replace with your actual general channel ID or use channel name search\n    const channel = member.guild.channels.cache.find(\n      (ch) => ch.name === \"1309058126217084984\" && ch.type === 0, // 0 = GuildText\n    );\n\n    if (!channel) return;\n\n    channel.send(\n      `üéâ Welcome to the server, <@${member.id}>! We're glad to have you here.`,\n    );\n  },\n};\n","path":null,"size_bytes":437,"size_tokens":null},"commands/info.js":{"content":"const { SlashCommandBuilder } = require('discord.js');\r\n\r\nmodule.exports = {\r\n  data: new SlashCommandBuilder()\r\n    .setName('info')\r\n    .setDescription('Show server and user info'),\r\n  async execute(interaction) {\r\n    const { guild, channel, user } = interaction;\r\n    await interaction.reply(`Server: ${guild.name}\\nUser: ${user.tag}\\nChannel: ${channel.name}`);\r\n  },\r\n};\r\n","path":null,"size_bytes":379,"size_tokens":null},"events/ready.js":{"content":"module.exports = {\r\n  name: 'ready',\r\n  once: true,\r\n  execute(client) {\r\n    console.log(`${client.user.tag} is online`);\r\n    client.user.setActivity('/help for commands', { type: 'PLAYING' });\r\n  },\r\n};\r\n","path":null,"size_bytes":207,"size_tokens":null},"commands/mute.js":{"content":"const { SlashCommandBuilder, PermissionsBitField } = require('discord.js');\r\nconst { MessageFlags } = require('discord.js');\r\n\r\n\r\nmodule.exports = {\r\n  data: new SlashCommandBuilder()\r\n    .setName('mute')\r\n    .setDescription('Mute a user in voice channel')\r\n    .addUserOption(option =>\r\n      option.setName('target')\r\n        .setDescription('User to mute')\r\n        .setRequired(true)),\r\n  async execute(interaction) {\r\n    const member = interaction.options.getMember('target');\r\n\r\n    if (!member.voice.channel) {\r\n      return interaction.reply({ content: '‚ùå User is not in a voice channel.', flags: MessageFlags.Ephemeral\r\n });\r\n    }\r\n\r\n    try {\r\n      await member.voice.setMute(true);\r\n      await interaction.reply(`üîá ${member.user.tag} has been muted.`);\r\n    } catch (error) {\r\n      console.error('Mute error:', error);\r\n      await interaction.reply({ content: '‚ùå Failed to mute the user.', flags: MessageFlags.Ephemeral\r\n });\r\n    }\r\n  }\r\n};\r\n","path":null,"size_bytes":969,"size_tokens":null},"commands/say.js":{"content":"const { SlashCommandBuilder } = require('discord.js');\r\nconst { MessageFlags } = require('discord.js');\r\n\r\nmodule.exports = {\r\n  data: new SlashCommandBuilder()\r\n    .setName('say')\r\n    .setDescription('Make the bot say something in this channel')\r\n    .addStringOption(option =>\r\n      option.setName('message')\r\n        .setDescription('The message to say')\r\n        .setRequired(true)\r\n    ),\r\n  async execute(interaction) {\r\n    const message = interaction.options.getString('message');\r\n\r\n    try {\r\n      await interaction.channel.send(message);\r\n      await interaction.reply({ content: '‚úÖ Message sent.', flags: MessageFlags.Ephemeral });\r\n    } catch (error) {\r\n      console.error('Error in /say command:', error);\r\n      await interaction.reply({ content: '‚ùå Failed to send the message.', flags: MessageFlags.Ephemeral });\r\n    }\r\n  },\r\n};\r\n","path":null,"size_bytes":857,"size_tokens":null},"events/messageCreate.js":{"content":"const {\n  EmbedBuilder,\n  ActionRowBuilder,\n  ButtonBuilder,\n  ButtonStyle,\n} = require(\"discord.js\");\r\n\r\nmodule.exports = {\r\n  name: \"messageCreate\",\r\n  async execute(message, client) {\r\n    if (message.partial) {\r\n      try {\r\n        message = await message.fetch();\r\n      } catch (error) {\r\n        console.error(\"‚ùå Failed to fetch partial message:\", error);\r\n        return;\r\n      }\r\n    }\r\n\r\n    if (message.author.bot) return;\r\n\r\n    // Check for DM\r\n    if (message.channel.type === 1) {\r\n      const modChannel = await client.channels.fetch(\n        process.env.MOD_CHANNEL_ID,\n      );\r\n      if (!modChannel) return;\r\n\r\n      const embed = new EmbedBuilder()\r\n        .setTitle(`üì® New DM from ${message.author.tag}`)\r\n        .setDescription(message.content || \"*No text content*\")\r\n        .setColor(\"Blue\")\r\n        .setFooter({ text: `User ID: ${message.author.id}` })\r\n        .setTimestamp();\r\n\r\n      const row = new ActionRowBuilder().addComponents(\r\n        new ButtonBuilder()\r\n          .setCustomId(`reply_${message.author.id}`)\r\n          .setLabel(\"Reply\")\r\n          .setStyle(ButtonStyle.Primary),\r\n      );\r\n\r\n      await modChannel.send({ embeds: [embed], components: [row] });\r\n    }\n\n    if (message.author.bot) return;\n\n    const stickyData = client.stickyMessages?.get(message.channel.id);\n    if (!stickyData) return;\n\n    try {\n      // Delete previous sticky message\n      const prevStickyMsg = await message.channel.messages.fetch(\n        stickyData.messageId,\n      );\n      if (prevStickyMsg) await prevStickyMsg.delete();\n\n      // Send new sticky message\n      const newStickyMsg = await message.channel.send(stickyData.content);\n\n      // Update stored sticky message ID\n      client.stickyMessages.set(message.channel.id, {\n        messageId: newStickyMsg.id,\n        content: stickyData.content,\n      });\n    } catch (err) {\n      // Handle missing messages or permissions errors silently\n      console.error(\"Sticky message update error:\", err);\n    }\r\n  },\r\n};\r\n","path":null,"size_bytes":2016,"size_tokens":null},"commands/disconnect.js":{"content":"const { SlashCommandBuilder } = require('discord.js');\r\nconst { MessageFlags } = require('discord.js');\r\n\r\n\r\nmodule.exports = {\r\n  data: new SlashCommandBuilder()\r\n    .setName('disconnect')\r\n    .setDescription('Disconnect a user from voice channel')\r\n    .addUserOption(option =>\r\n      option.setName('target')\r\n        .setDescription('User to disconnect')\r\n        .setRequired(true)),\r\n  async execute(interaction) {\r\n    const member = interaction.options.getMember('target');\r\n\r\n    if (!member.voice.channel) {\r\n      return interaction.reply({ content: '‚ùå User is not in a voice channel.', flags: MessageFlags.Ephemeral });\r\n    }\r\n\r\n    try {\r\n      await member.voice.disconnect();\r\n      await interaction.reply(`‚ùå ${member.user.tag} has been disconnected from voice.`);\r\n    } catch (error) {\r\n      console.error('Disconnect error:', error);\r\n      await interaction.reply({ content: '‚ùå Failed to disconnect the user.', flags: MessageFlags.Ephemeral });\r\n    }\r\n  }\r\n};\r\n","path":null,"size_bytes":992,"size_tokens":null},"commands/clear.js":{"content":"const { SlashCommandBuilder } = require(\"discord.js\");\n\nmodule.exports = {\n  data: new SlashCommandBuilder()\n    .setName(\"clear\")\n    .setDescription(\"Delete a number of messages in the current channel\")\n    .addIntegerOption((option) =>\n      option\n        .setName(\"amount\")\n        .setDescription(\"Number of messages to delete (1‚Äì100)\")\n        .setRequired(true),\n    ),\n  async execute(interaction) {\n    const amount = interaction.options.getInteger(\"amount\");\n\n    // Permission check\n    if (!interaction.member.permissions.has(\"ManageMessages\")) {\n      return interaction.reply({\n        content: \"‚ùå You don't have permission to delete messages.\",\n        ephemeral: true,\n      });\n    }\n\n    if (amount < 1 || amount > 100) {\n      return interaction.reply({\n        content: \"‚ùå Please provide a number between 1 and 100.\",\n        ephemeral: true,\n      });\n    }\n\n    try {\n      await interaction.channel.bulkDelete(amount, true);\n      await interaction.reply({\n        content: `‚úÖ Deleted ${amount} messages.`,\n        ephemeral: true,\n      });\n    } catch (error) {\n      console.error(error);\n      await interaction.reply({\n        content:\n          \"‚ùå Failed to delete messages. They may be older than 14 days.\",\n        ephemeral: true,\n      });\n    }\n  },\n};\n","path":null,"size_bytes":1298,"size_tokens":null},"commands/help.js":{"content":"const { SlashCommandBuilder } = require('discord.js');\r\n\r\nmodule.exports = {\r\n  data: new SlashCommandBuilder()\r\n    .setName('help')\r\n    .setDescription('List all available commands'),\r\n  async execute(interaction) {\r\n    await interaction.reply(\r\n      'Available commands:\\n' +\r\n      '/hello - Say hello\\n' +\r\n      '/info - Show server and user info\\n' +\r\n      '/say <message> <channel> - Send a message to a selected channel\\n'\r\n    );\r\n  },\r\n};\r\n","path":null,"size_bytes":455,"size_tokens":null},"commands/move.js":{"content":"const { SlashCommandBuilder, ChannelType } = require('discord.js');\r\nconst { MessageFlags } = require('discord.js');\r\n\r\n\r\nmodule.exports = {\r\n  data: new SlashCommandBuilder()\r\n    .setName('move')\r\n    .setDescription('Move a user to another voice channel')\r\n    .addUserOption(option =>\r\n      option.setName('target')\r\n        .setDescription('User to move')\r\n        .setRequired(true))\r\n    .addChannelOption(option =>\r\n      option.setName('channel')\r\n        .setDescription('Voice channel to move the user to')\r\n        .addChannelTypes(ChannelType.GuildVoice)\r\n        .setRequired(true)),\r\n  async execute(interaction) {\r\n    const member = interaction.options.getMember('target');\r\n    const targetChannel = interaction.options.getChannel('channel');\r\n\r\n    if (!member.voice.channel) {\r\n      return interaction.reply({ content: '‚ùå User is not in a voice channel.', flags: MessageFlags.Ephemeral });\r\n    }\r\n\r\n    try {\r\n      await member.voice.setChannel(targetChannel);\r\n      await interaction.reply(`‚û°Ô∏è Moved ${member.user.tag} to ${targetChannel.name}`);\r\n    } catch (error) {\r\n      console.error('Move error:', error);\r\n      await interaction.reply({ content: '‚ùå Failed to move the user.', flags: MessageFlags.Ephemeral });\r\n    }\r\n  }\r\n};\r\n","path":null,"size_bytes":1271,"size_tokens":null},"events/interactionCreate.js":{"content":"const { hasRequiredRole, hasAdminPermission } = require('../utils/permissions');\r\nconst { ModalBuilder, TextInputBuilder, TextInputStyle, ActionRowBuilder } = require('discord.js');\r\nconst { MessageFlags } = require('discord.js');\r\n\r\n\r\nmodule.exports = {\r\n  name: 'interactionCreate',\r\n  async execute(interaction, client) {\r\n    // Handle slash commands\r\n    if (interaction.isChatInputCommand()) {\r\n      const command = client.commands.get(interaction.commandName);\r\n      if (!command) return;\r\n\r\n      const member = interaction.member;\r\n      if (!hasRequiredRole(member) && !hasAdminPermission(member)) {\r\n        return interaction.reply({ content: '‚ùå You do not have a required role to use this command.', flags: MessageFlags.Ephemeral });\r\n      }\r\n\r\n      try {\r\n        await command.execute(interaction, client);\r\n      } catch (error) {\r\n        console.error(error);\r\n        await interaction.reply({ content: '‚ùå Error executing command.', flags: MessageFlags.Ephemeral });\r\n      }\r\n    }\r\n\r\n    // Handle \"Reply\" button click from mod channel\r\n    if (interaction.isButton() && interaction.customId.startsWith('reply_')) {\r\n      const userId = interaction.customId.split('_')[1];\r\n\r\n      const modal = new ModalBuilder()\r\n        .setCustomId(`modal_reply_${userId}`)\r\n        .setTitle(`Reply to ${userId}`);\r\n\r\n      const input = new TextInputBuilder()\r\n        .setCustomId('reply_message')\r\n        .setLabel('Your message')\r\n        .setStyle(TextInputStyle.Paragraph)\r\n        .setRequired(true);\r\n\r\n      const row = new ActionRowBuilder().addComponents(input);\r\n      modal.addComponents(row);\r\n\r\n      return interaction.showModal(modal);\r\n    }\r\n\r\n    // Handle modal submission with the reply\r\n    if (interaction.isModalSubmit() && interaction.customId.startsWith('modal_reply_')) {\r\n      const userId = interaction.customId.split('_')[2];\r\n      const replyContent = interaction.fields.getTextInputValue('reply_message');\r\n\r\n      try {\r\n        const user = await client.users.fetch(userId);\r\n        await user.send(`üì¨ **Reply from the team:**\\n${replyContent}`);\r\n        await interaction.reply({ content: `‚úÖ Replied to ${user.tag}`, flags: MessageFlags.Ephemeral });\r\n      } catch (err) {\r\n        console.error('Failed to send DM:', err);\r\n        await interaction.reply({ content: '‚ùå Could not DM the user.', flags: MessageFlags.Ephemeral });\r\n      }\r\n    }\r\n  }\r\n};","path":null,"size_bytes":2422,"size_tokens":null},"utils/configManager.js":{"content":"","path":null,"size_bytes":0,"size_tokens":null},"commands/sticky.js":{"content":"const { SlashCommandBuilder, MessageFlagsBitField } = require(\"discord.js\");\n\nmodule.exports = {\n  data: new SlashCommandBuilder()\n    .setName(\"sticky\")\n    .setDescription(\"Create a sticky message in a specified channel\")\n    .addChannelOption((option) =>\n      option\n        .setName(\"channel\")\n        .setDescription(\"The channel to create sticky message in\")\n        .setRequired(true),\n    )\n    .addStringOption((option) =>\n      option\n        .setName(\"message\")\n        .setDescription(\"The sticky message content\")\n        .setRequired(true),\n    ),\n\n  async execute(interaction, client) {\n    const channel = interaction.options.getChannel(\"channel\");\n    const text = interaction.options.getString(\"message\");\n\n    if (!channel.isTextBased()) {\n      return interaction.reply({\n        content: \"Please select a text-based channel.\",\n        flags: MessageFlagsBitField.Ephemeral,\n      });\n    }\n\n    try {\n      const stickyMsg = await channel.send(text);\n\n      if (!client.stickyMessages) client.stickyMessages = new Map();\n\n      client.stickyMessages.set(channel.id, {\n        messageId: stickyMsg.id,\n        content: text,\n      });\n\n      await interaction.reply({\n        content: `Sticky message created in ${channel}.`,\n        flags: MessageFlagsBitField.Ephemeral,\n      });\n    } catch (error) {\n      console.error(\"Error sending sticky message:\", error);\n      await interaction.reply({\n        content: \"Failed to send sticky message.\",\n        flags: MessageFlagsBitField.Ephemeral,\n      });\n    }\n  },\n};\n","path":null,"size_bytes":1541,"size_tokens":null},"registerCommands.js":{"content":"const { REST, Routes } = require('discord.js');\r\nconst fs = require('fs');\r\nrequire('dotenv').config();\r\n\r\nconst commands = [];\r\nconst commandFiles = fs.readdirSync('./commands').filter(file => file.endsWith('.js'));\r\n\r\nfor (const file of commandFiles) {\r\n  const command = require(`./commands/${file}`);\r\n  commands.push(command.data.toJSON());\r\n}\r\n\r\nconst rest = new REST({ version: '10' }).setToken(process.env.TOKEN);\r\n\r\n(async () => {\r\n  try {\r\n    console.log('Registering slash commands...');\r\n    await rest.put(\r\n      Routes.applicationGuildCommands(process.env.CLIENT_ID, process.env.GUILD_ID),\r\n      { body: commands },\r\n    );\r\n    console.log('Commands registered!');\r\n  } catch (error) {\r\n    console.error(error);\r\n  }\r\n})();\r\n","path":null,"size_bytes":744,"size_tokens":null},"keepalive.js":{"content":"const express = require(\"express\");\nconst app = express();\n\napp.get(\"/\", (req, res) => {\n  res.send(\"Bot is alive!\");\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => console.log(`KeepAlive server running on port ${PORT}`));\n","path":null,"size_bytes":243,"size_tokens":null},"commands/dm.js":{"content":"const { SlashCommandBuilder } = require('discord.js');\r\nconst { MessageFlags } = require('discord.js');\r\n\r\n\r\nmodule.exports = {\r\n  data: new SlashCommandBuilder()\r\n    .setName('dm')\r\n    .setDescription('Send a private message to a user via DM')\r\n    .addUserOption(option =>\r\n      option.setName('target')\r\n        .setDescription('User to DM')\r\n        .setRequired(true))\r\n    .addStringOption(option =>\r\n      option.setName('message')\r\n        .setDescription('The message to send')\r\n        .setRequired(true)),\r\n  async execute(interaction) {\r\n    const user = interaction.options.getUser('target');\r\n    const message = interaction.options.getString('message');\r\n\r\n    try {\r\n      await user.send(message);\r\n      await interaction.reply({ content: `üì© Message sent to ${user.tag}`, flags: MessageFlags.Ephemeral });\r\n    } catch (error) {\r\n      console.error('DM error:', error);\r\n      await interaction.reply({ content: `‚ùå Failed to send a DM to ${user.tag}. They might have DMs disabled.`, flags: MessageFlags.Ephemeral });\r\n    }\r\n  }\r\n};\r\n","path":null,"size_bytes":1061,"size_tokens":null}},"version":2}